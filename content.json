{"posts":[{"title":"21days muduo C++11","text":"写在最前 作为一名服务器程序员，Linux网络编程及其重要，但是之前的我，根本就没重视这一块，导致有时间，重新梳理一下网络编程知识，学以致用，以陈硕的muduo网络库为基础，实现一个C++11版本的muduo网络库。 本博客记录21天搭建过程 网络编程基础知识1. 阻塞，非阻塞，同步，异步 其实阻塞、非阻塞，同步和异步，对于初学者来说，知道大概的意思即可，真正领会其含义，还是在实践当中。文字本身并不能准确表达出其中的区别 1.1 阻塞 非阻塞 首先明确一下，read,write,recv等函数，它们没有阻塞非阻塞一说，阻塞非阻塞是说fd。 我们拿read函数读取socket fd网络数据来举例。当调用read(fd,buf,size)的时候（就是从内核区的fd的read缓冲区读数据到用户区） fd是阻塞的，那么当fd的缓冲区没有数据，线程会挂起，直到fd的缓冲区有数据，才会继续执行（当拿到CPU时间片的情况下）。如果有数据的话，就会直接向下执行 fd是非阻塞的，那么当fd的缓冲区没有数据，线程不会挂起，它会继续执行，只不过返回结果是-1，根据返回结果-1并且errno=EGAGIN可以判断是fd没有数据 。如果有数据，返回一个&gt;0的数。 1.2 同步 异步 这组词是描述I/O把数据从内核区搬运到与用户区的方式，也可以描述业务逻辑的处理方式。 比如同样是从fd中读取数据到用户程序中。 1.2.1 同步123456char buf[1024] = {0}int size = recv(sockfd,buf,1024,0);if (size &gt; 0){ 处理数据} 调用IO接口的时候，数据是应用程序 从内核区的 TCP 接收缓冲区搬运到用户区的。 搬运数据花的时间是应用程序的时间, 都是用户态操作。也就是该线程是等搬运完数据之后再继续向下执行的。 1.2.2 异步1aio_read(&amp;aiocb) aiocb中会有一个指针指向定义的一个 aio_buf ，调用异步 IO 接口，会注册一个 sigio 信号处理函数，当操作系统搬运完数据会通过发信号 通知给应用程序，搬运数据花的时间是内核的。也就是调用完aio_read之后，该线程继续执行，不会等数据从内核区拷贝到用户区的，这个工作交给内核操作。 linux 系统中，除了aio_read,aio_write等aio_xxx函数外，其它函数都是同步函数。 1.2.3 业务逻辑中的同步异步同步异步在业务逻辑中也存在。比如一个log日志系统，会把日志写到文件中去。 日志是同步系统。当调用LogInfo(&quot;write log&quot;) 的时候，代码执行逻辑是等LogInfo把这行文字写到文件中之后才继续向下执行。 日志是异步系统。当调用LogInfo(&quot;write log&quot;) 的时候，直接继续向下执行，不会等写到文件。因为写日志的工作交给了另外一个线程来执行。这就是异步日志。 在读写 I/O 的时候，所有阻塞和非阻塞都是同步，只有使用特殊 API 的才是异步。 —-陈硕","link":"/2023/10/24/21days-muduo-C-11/"}],"tags":[{"name":"muduo","slug":"muduo","link":"/tags/muduo/"}],"categories":[],"pages":[]}