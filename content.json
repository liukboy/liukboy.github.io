{"posts":[{"title":"21days muduo C++11(day01)","text":"今日目标 网络库外围模块：不可复制类，日志类 不可复制类当我们不想让一个类拥有拷贝构造能力，以及赋值能力，那么我们可以采取很多种方式。 声明为private属性，那么不可以直接拷贝构造。 但是如果定义一个public函数里面调用了这个private函数，还是可以拷贝构造的。所以private只是代表了不可以直接拷贝构造，间接拷贝构造还是可以的。 还可以只声明不定义 delete。明确说明阻止编译器生成拷贝构造函数。 以上都是针对一个类，但是大型项目中，会有很多类都有这个需求，每个类单独处理拷贝构造函数和赋值函数，比较麻烦。所以可以写一个父类NonCopyable，父类中的拷贝构造函数和赋值函数都delete掉，其他类继承NonCopyable. 代码见base/NonCopyable.h 日志类日志其实是一个大工程，自己写可能会耗费很长时间，我们这先写一个简单版。后面有时间再复现一下muduo的日志库。 写在最后在找日志库的时候，发现一个很好的日志库-spdlog，这个库可以学到一些C++技巧：头文件库和静态库的使用、锁应该如何使用、容器和容器适配器的关系、如何实现线程安全的队列等。 列在TODO list中，之后好好看一下这个库。 TODO[] spdlog库学习[] muduo日志库的完善","link":"/2023/10/26/21days-muduo-C-11-day01/"},{"title":"手把手教你写日志库C++(Day01)","text":"GitHub tinylog日志库 前言首先在一个服务器系统中写日志，就是把一些数据写到终端或者文件中去。为了梳理整个流程，我们先把日志写到终端，走一遍整个流程，之后我们再一步步优化。 日志格式日志包含以下几个重要数据即可 时间 进程PID 日志级别 日志内容 所在文件名，行号这些数据就可以满足基本要求了 日志使用对于C++来说，流式输出是最符合习惯的，也最方便，所以我们也采用这种方式LOG_INFO &lt;&lt; &quot;hello,log; Log类写日志，说白了，就是把一些字符写到一个字符串当中去，然后输出出来。如果这样的话，我们就封装一个Log类，里面包含输出日志的接口，之后具体实现可以更改，接口是不变的。 极简实现查看Day01的代码 测试1234567int main(){ LOG_INFO &lt;&lt; &quot;hello,log&quot;; LOG_INFO &lt;&lt; 11111; LOG_INFO &lt;&lt; 1.000; LOG_INFO &lt;&lt; true;} 输出结果 整个代码是很简陋的，但是整体流程就是这样日志是放在一个Log中的string，然后把日期，时间，日志级别，日志内容，文件行号都append到这个string中去，在析构的时候进行打印输出这个string。这里面的流式设计也需要好好思考一下","link":"/2023/10/30/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E6%97%A5%E5%BF%97%E5%BA%93C-Day01/"},{"title":"手把手教你写日志库C++(Day02)","text":"昨天实现的日志功能，有几个功能点是有严重问题的 存储日志的载体不能是string，因为string每次创建都是在堆上，频繁创建和销毁，很耗费性能的，所以需要用原始的栈上数组即可。 把流式操作 &lt;&lt; 拆分成LogStream类，不要和log类耦合 查看代码 Day02 测试12345678int main(){ LOG_INFO &lt;&lt; &quot;hello,log&quot;; LOG_DEBUG &lt;&lt; 5; LOG_WARN &lt;&lt; 2.000; LOG_ERROR &lt;&lt; true; return 0;}","link":"/2023/10/30/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E6%97%A5%E5%BF%97%E5%BA%93C-Day02/"},{"title":"手把手教你写日志库C++(Day03)","text":"今天把日志写到文件中去。其实原理很简单，只是把原来输出到终端编程现在的文件即可。但是其中有一些细节需要处理 细节 新建可写文件，模式为追加ae 如果文件满了，需要重建一个新的文件 如果跨天了，也会新建一个文件 每3s会刷新一下缓冲区到文件 当写日志次数超过一个阈值，也会触发刷新缓冲区 自定义文件的缓冲区为64 * 1024 （这个应该是需要根据经验来的，这里直接使用muduo的设计）","link":"/2023/10/31/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E6%97%A5%E5%BF%97%E5%BA%93C-Day03/"},{"title":"手把手教你写异步日志库C++","text":"日志目标实现步骤 先实现一个同步日志，输出到控制台，也就是说 LOG_INFO &lt;&lt; &quot;hello&quot; &lt;&lt; myname; 这时候在终端显示的是 “hello,lk” 把日志输出到文件中去 异步日志，前后端分离 优化 benchmark 日志格式日志前端日志后端在实现前端之后， 参考资料：","link":"/2023/10/30/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E6%97%A5%E5%BF%97%E5%BA%93C/"},{"title":"21days muduo C++11","text":"写在最前 作为一名服务器程序员，Linux网络编程及其重要，但是之前的我，根本就没重视这一块，现在有时间，重新梳理一下网络编程知识，学以致用，以陈硕的muduo网络库为基础，实现一个C++11版本的muduo网络库。 本博客记录21天搭建过程 网络编程基础知识1. 阻塞，非阻塞，同步，异步 其实阻塞、非阻塞，同步和异步，对于初学者来说，知道大概的意思即可，真正领会其含义，还是在实践当中。文字本身并不能准确表达出其中的区别 1.1 阻塞 非阻塞 首先明确一下，read,write,recv等函数，它们没有阻塞非阻塞一说，阻塞非阻塞是说fd。 我们拿read函数读取socket fd网络数据来举例。当调用read(fd,buf,size)的时候（就是从内核区的fd的read缓冲区读数据到用户区） fd是阻塞的，那么当fd的缓冲区没有数据，线程会挂起，直到fd的缓冲区有数据，才会继续执行（当拿到CPU时间片的情况下）。如果有数据的话，就会直接向下执行 fd是非阻塞的，那么当fd的缓冲区没有数据，线程不会挂起，它会继续执行，只不过返回结果是-1，根据返回结果-1并且errno=EGAGIN可以判断是fd没有数据 。如果有数据，返回一个&gt;0的数。 1.2 同步 异步 这组词是描述I/O把数据从内核区搬运到与用户区的方式，也可以描述业务逻辑的处理方式。 比如同样是从fd中读取数据到用户程序中。 1.2.1 同步123456char buf[1024] = {0}int size = recv(sockfd,buf,1024,0);if (size &gt; 0){ 处理数据} 调用IO接口的时候，数据是应用程序 从内核区的 TCP 接收缓冲区搬运到用户区的。 搬运数据花的时间是应用程序的时间, 都是用户态操作。也就是该线程是等搬运完数据之后再继续向下执行的。 1.2.2 异步1aio_read(&amp;aiocb) aiocb中会有一个指针指向定义的一个 aio_buf ，调用异步 IO 接口，会注册一个 sigio 信号处理函数，当操作系统搬运完数据会通过发信号 通知给应用程序，搬运数据花的时间是内核的。也就是调用完aio_read之后，该线程继续执行，不会等数据从内核区拷贝到用户区的，这个工作交给内核操作。 linux 系统中，除了aio_read,aio_write等aio_xxx函数外，其它函数都是同步函数。 1.2.3 业务逻辑中的同步异步同步异步在业务逻辑中也存在。比如一个log日志系统，会把日志写到文件中去。 日志是同步系统。当调用LogInfo(&quot;write log&quot;) 的时候，代码执行逻辑是等LogInfo把这行文字写到文件中之后才继续向下执行。 日志是异步系统。当调用LogInfo(&quot;write log&quot;) 的时候，直接继续向下执行，不会等写到文件。因为写日志的工作交给了另外一个线程来执行。这就是异步日志。 在读写 I/O 的时候，所有阻塞和非阻塞都是同步，只有使用特殊 API 的才是异步。 —-陈硕","link":"/2023/10/24/21days-muduo-C-11/"},{"title":"红黑树+Hash+B+树 备忘录","text":"红黑树前言红黑树基础知识，这里就不再赘述了，详情可以看红黑树（图解+秒懂+史上最全），写的非常好，respect！ BST(可能退化成单链表) –&gt; AVL(只适合查询，不适合频繁插入删除，因为每次增删操作都会旋转) –&gt; RBTree(牺牲严格的平衡条件，换区少量的旋转操作，不超过3次就可以解决不平衡问题)，最坏情况都是O(logN)完成查找 红黑树思考 红黑树都用在什么地方主要是用红黑树的插入删除查找 时间复杂度是 O(logN).所以需要快速查找的地方都可能用到。这里的竞争者就是哈希表.红黑树多出来一个优点： 中序遍历是有顺序的 epoll Map,Set(C++) 这里用到了顺序这个特性 定时器（有待补充） 补充强查找数据结构 哈希表 跳表 B/B+树 RBTree 定义下红黑树的结构，不需要实现具体操作 123456789101112131415typedef int KEY_TYPE;typedef struct _rbtree_node { unsigned char color; struct _rbtree_node *right; struct _rbtree_node *left; struct _rbtree_node *parent; KEY_TYPE key; void *value;} rbtree_node;typedef struct _rbtree { rbtree_node *root; rbtree_node *nil;} rbtree; 红黑树对比哈希表的优势 红黑树 哈希表 有序 无需 最差情况Log(N) 最差情况O(N) 有多少元素就分配多少内存 预先估计大小，rehash比较消耗性能 B/B+ 树漫画：什么是B+树？B树和B+树详解 M叉树，用来做数据库的索引B 树： 中间节点包含数据B+树：只有叶子节点包含数据 Hash 手写一个简易hash表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;// 定义哈希表的节点template&lt;typename K, typename V&gt;struct HashNode { K key; V value; HashNode(const K&amp; k, const V&amp; v) : key(k), value(v) {}};// 哈希表类定义template&lt;typename K, typename V, typename Hash = std::hash&lt;K&gt;&gt;class HashMap {public: explicit HashMap(int size = 100) : size_(size), count_(0), table_(size) {} // 向哈希表中插入键值对 void insert(const K&amp; key, const V&amp; value) { int index = hashFunction(key); for (auto it = table_[index].begin(); it != table_[index].end(); ++it) { if ((*it).key == key) { (*it).value = value; // 如果键已经存在，则更新其对应的值 return; } } table_[index].push_back(HashNode&lt;K, V&gt;(key, value)); count_++; } // 根据键查找对应的值 bool find(const K&amp; key, V&amp; value) { int index = hashFunction(key); for (auto it = table_[index].begin(); it != table_[index].end(); ++it) { if ((*it).key == key) { value = (*it).value; return true; // 找到键，并将对应的值赋给参数value } } return false; // 未找到键 } // 从哈希表中删除指定的键值对 void erase(const K&amp; key) { int index = hashFunction(key); for (auto it = table_[index].begin(); it != table_[index].end(); ++it) { if ((*it).key == key) { table_[index].erase(it); // 删除节点 count_--; return; } } }private: std::vector&lt;std::list&lt;HashNode&lt;K, V&gt;&gt;&gt; table_; // 哈希表存储数据的数组，每个元素是一个链表 int size_; // 哈希表的大小（桶数量） int count_; // 当前存储在哈希表中的键值对数量 Hash hashFunction; // 哈希函数对象 // 根据键计算哈希值，并映射到合适的桶索引 int hashFunction(const K&amp; key) { return hashFunction(key) % size_; }}; 新认识上面写的hash表和STL的中有一个最大的不同，就是每个桶之间是没有联系的以前以为STL中的unordered_map的哈希表是这样的但是这样的话，遍历整个map,时间复杂度大概是O(N+K),K是桶的个数，而K一般都比较大。所以，为了遍历时间复杂度为O(N),真正的结构是具体分析看 拉链法的 unordered_map 和你想象中的不一样新建一个unordered_map,成员包括 数组buckets，数组成员是指向链表节点的指针 _M_before_begin哨兵节点，可以理解为一个虚拟链表节点当插入一个节点的时候 在bucket有值的时候，都是通过前一个指针和头插法插入到对应的 bucket 内。 如果 bucket 没有值，就会把哨兵节点切换到新的 bucket 中。注意插入节点都是使用 头插法 小优化：当每个桶中的链表长度超过一个阈值（比如256）的时候，将链表转化为红黑树或者堆 负载因子 &gt; 1,需要rehash；小于0.1，也需要rehash。在这之间，就会拉链法或者开放寻址法处理hash冲突 布隆过滤器 什么场景下用布隆过滤器对于红黑树，hash表，都是存储了key + value。如果我们只想知道key存不存在，为了节省内存，就不需要存value。 数据库查找某个文件在不在 垃圾邮件过滤算法 构成bitmap + 多个hash函数 怎么确定bitmap大小和hash函数的个数，才能使假阳率最低？有数学证明，输入要保存的数据个数，还有期望的假阳率，就会给出最佳bitmap大小和hash个数 为什么很多hash函数个数是31？因为数学证明，在bitmap大小确定的情况下，31个哈希函数使得假阳率最低。","link":"/2023/11/27/%E7%BA%A2%E9%BB%91%E6%A0%91+Hash+B%E6%A0%91/"}],"tags":[{"name":"muduo,C++","slug":"muduo-C","link":"/tags/muduo-C/"},{"name":"log","slug":"log","link":"/tags/log/"},{"name":"基础知识","slug":"基础知识","link":"/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"categories":[{"name":"基础知识","slug":"基础知识","link":"/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"pages":[]}